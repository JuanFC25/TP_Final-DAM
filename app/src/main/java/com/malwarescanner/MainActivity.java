package com.malwarescanner;

import androidx.annotation.Nullable;
import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.core.app.NotificationCompat;
import androidx.core.app.NotificationManagerCompat;
import androidx.core.content.ContextCompat;
import androidx.recyclerview.widget.GridLayoutManager;
import androidx.recyclerview.widget.RecyclerView;
import androidx.swiperefreshlayout.widget.SwipeRefreshLayout;
import android.Manifest;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.pm.PackageManager;
import android.database.Cursor;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.os.Looper;
import android.preference.PreferenceManager;
import android.provider.DocumentsContract;
import android.provider.MediaStore;
import android.provider.Telephony;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.Toast;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonObject;
import com.malwarescanner.Modelo.AnalisisArchivo;
import com.malwarescanner.Recycler.ArchivoRecyclerAdapter;
import com.malwarescanner.Repository.ArchivoRepository;
import com.malwarescanner.Services.ObtenerScanService;
import com.malwarescanner.databinding.FileScannerBinding;
import com.malwarescanner.interfaces.AccionesArchivo;
import com.malwarescanner.utils.FAQArchivo;
import com.malwarescanner.utils.ReceptorSMS;
import java.io.File;
import java.io.IOException;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.List;
import okhttp3.MediaType;
import okhttp3.MultipartBody;
import okhttp3.RequestBody;
import retrofit2.Call;
import retrofit2.Response;
import retrofit2.Retrofit;
import retrofit2.converter.gson.GsonConverterFactory;


public class MainActivity extends AppCompatActivity {

    public final static String API_KEY = "78d8f5f6897ecd2d9755de0a3fec4f47c9b7885ded2868bf0ed9dee4113b64e4";
    public final String CANAL_MENSAJES_ID = "25";
    private FileScannerBinding binding;
    File archivoElegido;
    String idArchivoSubido;
    List<AnalisisArchivo> escaneos;
    Boolean flag;
    Integer codigoRespuesta;


    private RecyclerView recyclerView;
    private RecyclerView.Adapter mAdapter;
    private RecyclerView.LayoutManager layoutManager;
    private List<String> permisosPedidos = new ArrayList<String>();


    Menu menu;

    @Override
    public boolean onCreateOptionsMenu(Menu menu){
        getMenuInflater().inflate(R.menu.menu_toolbar, menu);
        return true;
    }

    //creo las opciones del menu
    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.menuAyuda:
                Log.i("TAG", "onOptionsItemSelected: Ayuda");
                Intent i1 = new Intent(this, FAQArchivo.class);
                startActivity(i1);
                return true;
            case R.id.menuScanner:
                Log.i("TAG", "onOptionsItemSelected: scanner");
                return true;
            case R.id.menuSMS:
                if(!verificarPermisos("SMS")){
                    pedirPermisoSMS();
                    return true;
                } else {
                    Log.i("TAG", "onOptionsItemSelected: sms");
                    Intent i2 = new Intent(this,ListaSMS.class);
                    startActivity(i2);
                    return true;
                }
            case R.id.menuOpciones:
                Log.i("TAG", "onOptionsItemSelected: opciones");
                Intent i3 = new Intent(this,Settings.class);
                startActivity(i3);
                return true;
            default:
                Toast.makeText(this, ". . . . ", Toast.LENGTH_LONG).show();
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);


        permisosPedidos.add(Manifest.permission.WRITE_EXTERNAL_STORAGE);
        permisosPedidos.add(Manifest.permission.READ_SMS);
        permisosPedidos.add(Manifest.permission.READ_EXTERNAL_STORAGE);

        //declaramos el binder
        binding = FileScannerBinding.inflate(getLayoutInflater());
        View view = binding.getRoot();
        setContentView(view);

        //setear la toolbar
        setSupportActionBar(findViewById(R.id.materialToolbar2));
        getSupportActionBar().setTitle("File Scanner");

        crearRecyclerView();
        modificarRecyclerView();
        configSwipe();

        //comprobacion externa de los permisos para leer y escribir archivos por si la funcion andaba mal.
       /* if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            if (ContextCompat.checkSelfPermission(MainActivity.this,
                    Manifest.permission.READ_EXTERNAL_STORAGE)
                    != PackageManager.PERMISSION_GRANTED) {
                Log.i("permisos", "mo tengo permiso ");
            } else {
                Log.i("permisos", "tengo permiso ");
            }
        }

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            if (ContextCompat.checkSelfPermission(MainActivity.this,
                    Manifest.permission.WRITE_EXTERNAL_STORAGE)
                    != PackageManager.PERMISSION_GRANTED) {
                Log.i("permisos", "mo tengo permiso ");
            } else {
                Log.i("permisos", "tengo permiso ");
            }
        }*/

        //creo canal de notificaciones
        createNotificationChannel();


        //inicio el broadcast Receiver 1
        BroadcastReceiver br1 = new ReceptorAnalisis();
        IntentFilter filtro1 = new IntentFilter();
        filtro1.addAction(ReceptorAnalisis.ACTION_RESP);
        getApplication().getApplicationContext().registerReceiver(br1,filtro1);

        //inicio el broadcast Receiver 2
        BroadcastReceiver br2 = new ReceptorSMS();
        IntentFilter filtro2 = new IntentFilter();
        filtro2.addAction(Telephony.Sms.Intents.SMS_RECEIVED_ACTION);
        getApplication().getApplicationContext().registerReceiver(br2,filtro2);


        //boton flotante para analizar un archivo, pregunto por los permisos, si no los tengo los pido y si los tengo abro el FileChooser
        binding.nuevoArchivo.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {

                if (!verificarPermisos("ARCHIVO")){
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                        if (ContextCompat.checkSelfPermission(MainActivity.this,
                                Manifest.permission.READ_EXTERNAL_STORAGE)
                                != PackageManager.PERMISSION_GRANTED) {
                            Log.i("permisos", "mo tengo permiso ");
                            pedirPermisoArchivo();
                        } else {
                            Log.i("permisos", "tengo permiso ");

                        }
                    }

                } else {
                    abrirFileChooser();
                }
            }
        });

        //boton flotante para borrar todos los analisis de archivos
        binding.borrarArchivos.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {

                if(escaneos.size() == 0 ) {
                    Toast.makeText(getApplicationContext(), "No hay analisis para borrar",Toast.LENGTH_SHORT).show();
                } else{
                    new AlertDialog.Builder(MainActivity.this).setTitle("Confirmación")
                            .setMessage("¿Desea eliminar todos los analisis?")
                            .setPositiveButton("Si", new DialogInterface.OnClickListener() {
                                @Override
                                public void onClick(DialogInterface dialogInterface, int i) {
                                    borrarArchivos();
                                    modificarRecyclerView();
                                }
                            })
                            .setNegativeButton("Cancelar",null)
                            .create().show();
                }
            }
        });



    }

    private void borrarArchivos() {

        flag = false;
        Thread thread = new Thread(new Runnable() {

            @Override
            public void run() {
                try  {
                    ArchivoRepository.getInstance(MainActivity.this).borrarTodosLosAnalisis();
                    flag = true;
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        });

        thread.start();

        while (!flag){
              Toast.makeText(this,"Por favor, espere mientras se realiza la operación",Toast.LENGTH_LONG).show();
        };

    }


    //acutaliza la lista de escaneos
    private void modificarRecyclerView() {
        obtenerEscaneos();
        mAdapter = new ArchivoRecyclerAdapter(escaneos);
        recyclerView.setAdapter(mAdapter);
    }

    //inicializas la lista de escaneos
    private void crearRecyclerView() {
        recyclerView = binding.recyclerFiles;
        recyclerView.setHasFixedSize(true);
        layoutManager = new GridLayoutManager(this,2);
        recyclerView.setLayoutManager(layoutManager);
    }


    private void configSwipe()      {
        binding.swipeFiles.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
            @Override
            public void onRefresh() {
                obtenerEscaneos();
                binding.swipeFiles.setRefreshing(false);
                modificarRecyclerView();
            }
        });
    }


    //abre el selector de archivos al hacer click en el boton flotante
    private void abrirFileChooser(){
        Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
        intent.setType("*/*");
        intent.addCategory(Intent.CATEGORY_OPENABLE);

        try {
            startActivityForResult(Intent.createChooser(intent,"Seleccione un archivo"), 100);
        } catch (Exception e) {
            Toast.makeText(this, "Se necesita un administrador de archivos para esta operación", Toast.LENGTH_LONG).show();
        }
    }

    //funcion que se encarga de manejar el resultado del filechooser
    @Override
    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
        if(requestCode==100 && resultCode == RESULT_OK && data != null){
            Uri uri = data.getData();
            Log.i("ARCHIVO ELEGIDO", uri.getPath());

            String path = uri.getPath();

            //aproximación 1: obtener el archivo mediante el uri
            //archivoElegido = new File(path);

            // aproximacion 2: usar una libreria externa desarrollada por otra persona.
//            try {
//                path = FileUtils.getFilePath(this,uri);
//            } catch (URISyntaxException e) {
//                e.printStackTrace();
//            }

            //aproximacion 3: funcion encontrada en StackOverflow
            //archivoElegido = new File(getRealPathFromURI_API19_and_later(uri));

            //aproximacion 4: tomar la aprimación 1 y hardcodear parte del path
            String primeraPartePath = "/storage/emulated/0/";
            int index = path.indexOf(":") + 1;
            int size = path.length();
            String segundaPartePath = path.substring(index,size);
            String pathFinal = primeraPartePath + segundaPartePath;

            Log.i("ARCHIVO ELEGIDO", " ");
            Log.i("ARCHIVO ELEGIDO", " ");

            Log.i("ARCHIVO ELEGIDO", "PATH URI: "+ uri.getPath());

            Log.i("ARCHIVO ELEGIDO", "PATH funcion Chatgpt: "+ getRealPathFromUri(uri));
            try {
                Log.i("ARCHIVO ELEGIDO", "PATH Fileutils: "+ FileUtils.getFilePath(this,uri));
            } catch (URISyntaxException e) {
                e.printStackTrace();
            };


            Log.i("ARCHIVO ELEGIDO", " ");

            //Log.i("ARCHIVO ELEGIDO", "PATH funcion: "+ path);
            archivoElegido = new File(pathFinal);
            File a = new File(pathFinal);
            Log.i("ARCHIVO ELEGIDO", "PATH funcion aproximacion 4: "+ pathFinal);
            Log.i("ARCHIVO ELEGIDO", "Existe: "+ archivoElegido.exists());
            Log.i("ARCHIVO ELEGIDO", "Path objeto file: "+ archivoElegido.getPath());
            Log.i("ARCHIVO ELEGIDO", "Path absoluto objeto file: "+ archivoElegido.getAbsolutePath());

            a.setReadable(true, false);
            a.setExecutable(true, false);
            a.setWritable(true, false);

            Log.i("ARCHIVO ELEGIDO", "Puedo leer: " + a.getAbsoluteFile().canRead());
            //pathGeneral = getRealPathFromURI_API19_and_later(this, uri);

            new AlertDialog.Builder(this).setTitle("Confirmación")
                    .setMessage("¿Desea subir el archivo seleccionado?")
                    .setPositiveButton("Subir", new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialogInterface, int i) {
                            try {
                                Toast.makeText(getApplicationContext(),"Por favor, espere mientras se realiza la operación",Toast.LENGTH_LONG).show();
                                subirArchivo();
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                        }
                    })
                    .setNegativeButton("Cancelar",null)
                    .create().show();

        }
        super.onActivityResult(requestCode, resultCode, data);
    }

    //funcion que crea el servicio que va a obtener el resultado del analisis
    private void crearServicioObtenerAnalisis(AnalisisArchivo archivoElegido) {

        Intent nuevoServicio = new Intent(MainActivity.this, ObtenerScanService.class);
        nuevoServicio.putExtra("archivo", archivoElegido);
        startService(nuevoServicio);
    }

    //borrar
    String getRealPathFromUri(Uri uri) {
        String[] projection = {MediaStore.Images.Media.DATA};
        Cursor cursor = getContentResolver().query(uri, projection, null, null, null);
        if (cursor == null) {
            return uri.getPath();
        } else {
            int column_index = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);
            cursor.moveToFirst();
            String filePath = cursor.getString(column_index);
            cursor.close();
            return filePath;
        }
    }

    public Integer subirArchivo() throws IOException {


        RequestBody requestFile = RequestBody.create(MediaType.parse("multipart/form-data"), archivoElegido);
        MultipartBody.Part body = MultipartBody.Part.createFormData("file", archivoElegido.getName(), requestFile);

        Gson gson = new GsonBuilder()
                .setLenient()
                .create();
        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl("https://www.virustotal.com/api/v3/")
                .addConverterFactory(GsonConverterFactory.create(gson))
                .build();
        AccionesArchivo accionesArchivo =retrofit.create(AccionesArchivo.class);

        flag = false;
        Thread thread = new Thread(new Runnable() {

            @Override
            public void run() {
                try  {


                    Call<JsonObject> llamada = accionesArchivo.uploadFile(API_KEY,body);

                    Response<JsonObject> res = null;
                    try{
                        res = llamada.execute();
                    }catch (IOException e){
                        e.printStackTrace();
                    }
                    JsonObject respuesta = res.body().getAsJsonObject("data");
                    idArchivoSubido = respuesta.get("id").getAsString();
                    System.out.println(idArchivoSubido);
                    System.out.println(res.code());
                    codigoRespuesta = res.code();

                    if(codigoRespuesta == 200){
                        AnalisisArchivo archivo = new AnalisisArchivo(System.currentTimeMillis(), archivoElegido.getName(), archivoElegido.getAbsolutePath(),idArchivoSubido);
                        guardarArchivoEnBD(archivo);

                        runOnUiThread(new Runnable() {
                            @Override
                            public void run() {
                                Toast.makeText(getApplicationContext(),"Archivo subido correctamente", Toast.LENGTH_LONG);
                                modificarRecyclerView();
                                crearServicioObtenerAnalisis(archivo);
                            }
                        });
                    } else if (codigoRespuesta == 429) {
                        Log.i("Subir Archivo", "Cuota diaria excedida");
                        runOnUiThread(new Runnable() {
                            @Override
                            public void run() {
                                Toast.makeText(getApplicationContext(), "Ha superado la cantidad de análisis disponibles para el día de hoy, por favor intente nuevamente mañana.", Toast.LENGTH_LONG).show();
                            }
                        });

                    } else {
                        Log.i("Subir Archivo", "Fallo la subida del archivo");
                    }

                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        });

        thread.start();

        return codigoRespuesta;
    }

    private void guardarArchivoEnBD(AnalisisArchivo archivoAsubir) {

        flag = false;
        Thread thread = new Thread(new Runnable() {

            @Override
            public void run() {
                try  {
                    Long idArchivo = ArchivoRepository.getInstance(MainActivity.this).insertarScan(archivoAsubir);
                    archivoAsubir.setId(Math.toIntExact(idArchivo));
                    flag = true;
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        });


        thread.start();

        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                while (!flag){
                };
            }
        });


    }

    public static String getRealPathFromURI_API19_and_later(Context context, Uri uri){
        String filePath = "";
        String wholeID = DocumentsContract.getDocumentId(uri);

        // Split at colon, use second item in the array
        String id = wholeID.split(":")[1];

        String[] column = { MediaStore.Images.Media.DATA };

        // where id is equal to
        String sel = MediaStore.Images.Media._ID + "=?";

        Cursor cursor = context.getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
                column, sel, new String[]{ id }, null);

        int columnIndex = cursor.getColumnIndex(column[0]);

        if (cursor.moveToFirst()) {
            filePath = cursor.getString(columnIndex);
        }
        cursor.close();
        return filePath;
    }


    public List<AnalisisArchivo> obtenerEscaneos(){

        flag = false;
        Thread thread = new Thread(new Runnable() {

            @Override
            public void run() {
                Looper.prepare();
                try  {
                    escaneos = ArchivoRepository.getInstance(MainActivity.this).obtenerDetecciones();
                    flag = true;

                } catch (Exception e) {
                    e.printStackTrace();
                }
                Looper.loop();
            }
        });

        thread.start();
        while (flag == false);

        return escaneos;
    }

    //verifica los permisos necesarios para utilizar las funciones
    public Boolean verificarPermisos(String caso){
        Boolean respuesta = false;
        switch (caso) {
            case "SMS":
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                    if (ContextCompat.checkSelfPermission(MainActivity.this,
                            Manifest.permission.READ_SMS)
                            != PackageManager.PERMISSION_GRANTED)  {
                        respuesta = false;
                    } else {
                        respuesta = true;
                    }
                }
                break;
            case "ARCHIVO":
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                    if ((ContextCompat.checkSelfPermission(MainActivity.this,
                            Manifest.permission.WRITE_EXTERNAL_STORAGE)
                            != PackageManager.PERMISSION_GRANTED) && (ContextCompat.checkSelfPermission(MainActivity.this,
                            Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)){
                        respuesta = false;
                    } else {
                        respuesta = true;
                    }
                }
                break;
        }
        return respuesta;
    }

    //funcion que pide los permisos para poder subir archivos
    public void pedirPermisoArchivo() {
        if(verificarPermisos("ARCHIVO") != true){
            Boolean a = ActivityCompat
                    .shouldShowRequestPermissionRationale(
                            MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE
                    );
            if (ActivityCompat
                    .shouldShowRequestPermissionRationale(
                            MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE
                    )) {
                AlertDialog.Builder builder =new AlertDialog.Builder(MainActivity.this);
                builder.setTitle("Atención")
                        .setMessage("Se necesitan los permisos de escritura para poder subir los archivos")
                        .setPositiveButton("Dar permiso",new DialogInterface.OnClickListener(){
                            public void onClick(DialogInterface dialog, int id) {
                                ActivityCompat.requestPermissions(MainActivity.this,
                                        new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
                                        1);
                            }
                        })
                        .setNegativeButton("Cancelar",new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog, int id) {
                                Toast.makeText( MainActivity.this,
                                                "No se podra utilizar la función hasta que se acepten los permisos",
                                                Toast.LENGTH_SHORT)
                                        .show();
                            }
                        });
                builder.create().show();
            } else {
                ActivityCompat.requestPermissions(MainActivity.this,
                        new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
                        1);
                Log.i("PERMISOS", "pedirPermisoArchivo: llega hasta aca?");
            }
        }
    }

    //funcion que pide los permisos para poder examinar los sms
    public void pedirPermisoSMS() {
        if(verificarPermisos("SMS") != true){
            if (ActivityCompat
                    .shouldShowRequestPermissionRationale(
                            MainActivity.this, permisosPedidos.get(1)
                    )) {
                AlertDialog.Builder builder =new AlertDialog.Builder(MainActivity.this);
                builder.setTitle("Atención")
                        .setMessage("Se necesitan los permisos de lectura de SMS para poder inspeccionar los mensajes")
                        .setPositiveButton("Dar permiso",new DialogInterface.OnClickListener(){
                            public void onClick(DialogInterface dialog, int id) {
                                ActivityCompat.requestPermissions(MainActivity.this,
                                        new String[]{Manifest.permission.READ_SMS},
                                        1);
                            }
                        })
                        .setNegativeButton("Cancelar",new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog, int id) {
                                Toast.makeText( MainActivity.this,
                                                "No se podra utilizar la función hasta que se acepten los permisos",
                                                Toast.LENGTH_SHORT)
                                        .show();
                            }
                        });
                builder.create().show();
            } else {
                ActivityCompat.requestPermissions(MainActivity.this,
                        new String[]{Manifest.permission.READ_SMS},
                        2);
            }
        }
    }


    public void onRequestPermissionsResult(int requestCode,
                                           String[] permissions, int[] grantResults) {
        Boolean permisoParaEscribirConcedido;
        Boolean permisoParaSMSConcedido;
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        switch (requestCode) {
            case 1:
                permisoParaEscribirConcedido = grantResults[0]
                        == PackageManager.PERMISSION_GRANTED;
                if (permisoParaEscribirConcedido) Log.i("PERMISOS", "HAY PERMISOS PARA ESCRIBIR");
                break;
            case 2:
                permisoParaSMSConcedido = grantResults[0]
                        == PackageManager.PERMISSION_GRANTED;
                if (permisoParaSMSConcedido) Log.i("PERMISOS", "HAY PERMISOS PARA LEER SMS");
                break;
        }
    }


    //broadcast que recibe la notificacion cuando termina un analisis
    public class ReceptorAnalisis extends BroadcastReceiver {
        public static final String ACTION_RESP =
                "com.malwarescanner.RESPUESTA_OPERACION";

        @Override
        public void onReceive(Context context, Intent intent) {
            Log.i("SERVICIO", "ESTOY EN LA ACTIVIDAD PRINCIPAL ");
            modificarRecyclerView();

            SharedPreferences pref = PreferenceManager.getDefaultSharedPreferences(context);
            boolean recibirArchivo = pref.getBoolean("permitirNotificacionesArchivo", false);

            if(recibirArchivo){
                Intent destino = new Intent(context, MainActivity.class);
                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
                PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, destino, 0);

                NotificationCompat.Builder mBuilder =
                        new NotificationCompat.Builder(context, CANAL_MENSAJES_ID)
                                .setSmallIcon(R.mipmap.logo_foreground)
                                .setContentTitle("ANALISIS TERMINADO")
                                .setContentText("El archivo que subio para analizar ha terminado, pulse aqui para verlo")
                                .setPriority(NotificationCompat.PRIORITY_DEFAULT)
                                .setContentIntent(pendingIntent)
                                .setAutoCancel(true);

                NotificationManagerCompat notificationManager =
                        NotificationManagerCompat.from(context);
                notificationManager.notify(25, mBuilder.build());
            }
        }
    }



    private void createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            CharSequence name = getString(R.string.channel_name);
            String description = getString(R.string.channel_description);
            int importance = NotificationManager.IMPORTANCE_DEFAULT;
            NotificationChannel channel =
                    new NotificationChannel(CANAL_MENSAJES_ID, name, importance);
            channel.setDescription(description);
            NotificationManager notificationManager =
                    getSystemService(NotificationManager.class);
            notificationManager.createNotificationChannel(channel);
        }
    }

}